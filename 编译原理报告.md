# 编译原理报告



## 1. 概述

这个实验中，我们的目的是做一个简化版C语言的编译器。这个编译器应当可以读入文件并将其中的高级语言转换成编译用的中间代码。

我们的工作分为几个部分，词法分析、语法分析、语法树生成和中间语言的生成。词法和语法的工作分别由lex和yacc的这两种工具来完成，通过对他们的定义，帮助我们自动生成语法树。



## 2. 语法设计

再进行词法和语法分析的工作之前

### 2.1 预期功能

设计语法之前，我们需要先明确这个语言应当可以接受的操作。因为这一语言是C的简化版本，所以C的基本操作应可以接受C的大部分基本操作。

我们计划的功能如下：

1. 变量的定义与赋值（变量的类型包括整数、浮点数、字符和空），其中变量根据其定义的位置可以为局部变量或是全局变量；
2. 函数的定义、实现和调用；
3. 加减乘除等四则运算；
4. 大于、小于等比较运算及连续的比较运算；
5. 与、或、非等逻辑运算；
6. if、if...else等选择语句；
7. for、while、do...while等循环语句；
8. return、break等跳转语句；

其中赋值和参数调用中也均可以使用复合运算。这些语句的格式都仿照C的格式，如else后可以直接连接一个语句，也可以通过{}在其中包含一整段程序或是再连接if形成else if的语句；if、while等语句后的（）中可以使用单个的值或是表达式作为判断的标准；while、if等语句后面不需要分号，但是do...while后面需要分号等。

对于C中的struct定义、指针运算等我们暂时不计划实现。



### 2.2 词法定义

#### 2.2.1 关键词

在设计好应当事先的功能之后，我们可以对关键词进行设计了。这一语言预期接受的关键词有:
int, void, float, char, if, else, do, while, for, return, break

#### 2.2.2 变量与值

而对于用户定义的identifier，我们要求与C一致，即第一个字符为字母（大小写均可）或下划线，之后可以出现任意字母、数字和下划线；对于用户提供的数值，除了一般的数字串和数字小数点数字串，直接省略小数点前的数字，直接从小数点开始的数字串来表示0到1之间的小数。

#### 2.2.3 运算符

因为支持运算，所以词法中还应该包含运算符的设定。这一语言接受的运算符包括：
+, -, *, /, (), {}, [], <, >, =, >=, <=, ==, !=,&&, ||, !, ;



### 2.3 语法

由于yacc使用的是LALR(1)的模式进行语法分析，所以我们的语法设计也基于这一点进行

最外层的token是program，由于设计中program下可以由多个declaration，因此设计为declaration declaration_list可以规约为declaration_list， 然后规约为program。

declaration有两种模式，一种是变量的声明，一种是函数的声明。变量声明的场合，declaration可以变为*类型声明+变量名+;*的模式，也就是*spec extvars ';'*（其中变量名可以是一个列表）；而函数的声明则是*类型+函数+函数实现*的样式，也就是*spec func stmtblock*。









```yacc
program
-> declaration_list

declaration_list
-> declaration declaration_list 						
->  declaration	

declaration
->  spec extvars ';'
->  spec func stmtblock

extvars
->  dec	
->  dec ',' extvars	

spec
->  type		

type
->  VOID			
->  INT			
->  CHAR		
->  FLOAT			

dec	
->  var	
->  var assignop init

assignop
->  '='

init
->  exp

var
->  IDENTIFIER

func
->  IDENTIFIER '(' paras ')'

paras
->  para ',' paras
->  para	

para
->  spec var 

stmtblock
->  '{' defs stmts '}'

stmts
->  stmt stmts
->  e

stmt
->  assignstmt
->  stmtblock	
->  selstmt	
->  loopstmt	
->  jstmt	

selstmt
->  IF '(' exp ')' stmt	
->  IF '(' exp ')' stmt ELSE stmt	

loopstmt
->  WHILE '(' exp ')' stmt
->  FOR '(' exp ';' exp ';' exp ')' stmt	
->  DO stmt WHILE '(' exp ')' ';'	

assignstmt
->  assign ';'

assign
->  var assignop assign	
->  exp

jstmt
->  BREAK ';'		
->  RETURN exp ';'	

defs
->  def defs
->  e

def
->  spec extvars ';'

exp
->  relationexp	
->  equalexp
->  addexp
->  multipexp	
->  e

primexp
->  IDENTIFIER	
->  CONSTANT
->  STRING_LITERAL
->  '(' exp ')'
->  call

unaryop
->  '+'	
->  '-'	
->  '*'
->  '!'

unaryexp
->  unaryop unaryexp	
->  leftexp

leftexp
->  primexp
->  leftexp '[' ']'
->  leftexp '(' ')'	
->  leftexp '(' args ')'			

args
->  exp ',' args
->  exp

relationexp
->  unaryexp
->  relationexp '<' addexp	
->  relationexp '>' addexp 	
->  relationexp LE addexp	
->  relationexp GE addexp

equalexp
->  equalexp EQ addexp
->  equalexp NE addexp	
->  unaryexp

addexp
->  unaryexp
->  addexp '+' multipexp
->  addexp '-' multipexp	

multipexp
->  unaryexp
->  multipexp '*' unaryexp	
->  multipexp '/' unaryexp	

call
->  IDENTIFIER '(' args ')' 
```



## 3. 词法分析

由上面的定义，我们就可以写出具体lex使用的词法了。词法具体的定义如下：

```C
DIGIT [0-9]
LETTER [A-za-z_]
E		[Ee][+-]?{D}+

/* define key worlds */
"char" "int" "float" "if" "else" "do" "while" "break" "for" "return" "void" "struct"

/* define user identifier and constant */
{LETTER}({LETTER}|{DIGIT})* // user identifier
{DIGIT}+ 					// number in the form of xxxx
{DIGIT}*"."{DIGIT}+ 		// number in the form of .xxx
{DIGIT}+"."{DIGIT}* 		// number ih the form of xx.xxx or xx.

/* define operators and symbols */
"&&""||""<="">=""==""!=""+""-""*""/""!"","".""=""<"">""{""}""("")""[""]"";""?"":"	
```





## 4. 语法分析与语法树的生成

### 4.1 语法树的设计

因为语法树中每个节点对应的语句不通，语法也不同，所以每个非叶节点都有可能由不同数量的子节点。在这样的情况下，语法树如果设计为子节点数目确定的树是浪费资源而不合理的。因此，我们将语法树设计为父子树，每个节点只记录自己的儿子数量、长子指针和自己的下一个兄弟，这样父亲就可以通过长子访问到自己的所有子节点。

再这个基础之上，我们可以定义createNewNode()函数来创建和初始化新的节点，通过insert()函数来负责将节点插入父节点中，以及print()函数将语法树打印以供检查。


```c
typedef struct Node Node;
struct Node
{
	Node * brother;	// the younger brother of this node
	Node * child;	// the first son of this node
	int No_Child; 	// the number of children of this node
	int col;		// the column bumber of the token or word
	int No_Line;	// the line number of the token or word
	char name[20];	// the text of the terminal or the name of the token
	int IsBegin; 	// if it is the elder brother of all siblings
};

/* 
function insert() will insert the node newchild into the node father as the last of it's sons.
*/
void insert(Node* father, Node* newchild)
{
	if (newchild == NULL) // the case if inserting a null ptr
		return;
	if (father->No_Child == 0) // insert when the father has no son
	{
		newchild->IsBegin = 1;
		father->child = newchild;
		father->No_Child++;
		return;
	}
    // normal case
	Node* focus = father->child;
	int i;
    // find the end of sibling list and inset the new node there
	for(i=0;i<father->No_Child - 1;i++)
		focus = focus->brother;
	focus->brother = newchild;
	father->No_Child++;
	return;
}

/*
newNode() will create a new node and set its name as parameter node_name, record the name and column number and return a pointer of this node
*/
Node* newNode (char* node_name,int line, int c)
{
	struct Node *p=(struct Node*)malloc(sizeof(struct Node));
	if (p==NULL) // if allocate memory failed
	{
		printf("Error:out of memory.\n");
		exit(1);
	}
    // set the default value of all property
    strncpy(p->name,node_name,20);
    p->brother=NULL;
    p->child=NULL;
    p->No_Line=line;
    p->No_Child=0;
    p->col= 0;
    p->IsBegin=0;
    return p;
}

/*
Iunction print() will output the tree pointed by the pointer root.
it will print the tree node name and put several "__" before accroding to the node's level. This function is realized through recursive way
*/
void print(Node* root, int level)
{
	int i;
	for ( i = 0; i < level; i++)
	{
		printf("__");
	}
	printf("%s\n",root->name);
	
	Node* focus = root->child;
	for (i = 0; i < root->No_Child; i++)
	{
		print(focus, level + 1);
		focus = focus->brother;
	}
	return;
}
```
























